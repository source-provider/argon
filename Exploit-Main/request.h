#pragma once
#define CURL_STATICLIB
#define _BACKEND_H_

#define BACKEND_DEBUG 0

#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <urlmon.h>
#include <sstream>

#include "XOR.h"
#include "curl/curl.h"


#pragma comment (lib, "Normaliz.lib")
#pragma comment (lib, "advapi32.lib")
#pragma comment (lib, "Wldap32.lib")
#pragma comment (lib, "Crypt32.lib")
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "urlmon.lib")

#include <iostream>
#include <istream>
#include <ostream>
#include <string>
#include <stdio.h>
#include <windows.h>

#include "curl/curl.h"

#pragma comment(lib,"ws2_32.lib")
#pragma comment(lib,"curl/libcurl_a.lib")
#pragma comment(lib,"Normaliz.lib")
#pragma comment(lib,"advapi32.lib")
#pragma comment(lib,"Crypt32.lib")
#pragma comment(lib,"Wldap32.lib")

void Init()
{
	curl_global_init(CURL_GLOBAL_ALL);
}

struct MemoryStruct {
	char* memory;
	size_t size;
};

static size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
	size_t realsize = size * nmemb;
	struct MemoryStruct* mem = (struct MemoryStruct*)userp;

	char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);
	if (ptr == NULL) {
		/* out of memory! */
		printf("not enough memory (realloc returned NULL)\n");
		return 0;
	}

	mem->memory = ptr;
	memcpy(&(mem->memory[mem->size]), contents, realsize);
	mem->size += realsize;
	mem->memory[mem->size] = 0;

	return realsize;
}

const char* Get(const char* _curl)
{
	CURL* curl_handle;
	CURLcode res;

	struct MemoryStruct chunk;

	chunk.memory = (char*)malloc(1);
	chunk.size = 0;

	curl_handle = curl_easy_init();

	curl_easy_setopt(curl_handle, CURLOPT_URL, _curl);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
	curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");

	res = curl_easy_perform(curl_handle);

	if (res != CURLE_OK) {
		return nullptr;
	}

	curl_easy_cleanup(curl_handle);

	return chunk.memory;
}

bool RequestSuccess = false;
int RequestStatusCode = 0;

std::string ReplaceAll(std::string str, const std::string& from, const std::string& to)
{
	size_t start_pos = 0;
	while ((start_pos = str.find(from, start_pos)) != std::string::npos)
	{
		str.replace(start_pos, from.length(), to);
		start_pos += to.length();
	}
	return str;
}

const uint8_t ToByte(std::string str, const size_t offset = 0)
{
	uint8_t b, n = 0;

	if (str[offset] == '?' && str[offset + 1] == '?')
		return n;

	for (int i = offset; i < offset + 2; b = 0, i++)
	{
		if (str[i] >= 0x61)
			b = str[i] - 0x57;
		else if (str[i] >= 0x41)
			b = str[i] - 0x37;
		else if (str[i] >= 0x30)
			b = str[i] - 0x30;

		if (i == offset)
			n += (b * 16);
		else {
			n += b;
		}
	}

	return n;
}

size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
	((std::string*)userp)->append((char*)contents, size * nmemb);
	return size * nmemb;
}

const char* Request(std::string url, std::string method, std::string body = "")
{
	CURL* curl;
	CURLcode res;
	std::string readBuffer;
	std::string hwid_header;

	HW_PROFILE_INFO hwinfo;
	GetCurrentHwProfile(&hwinfo);

	curl_global_init(CURL_GLOBAL_ALL);
	curl = curl_easy_init();

	if (curl)
	{
		struct curl_slist* chunk = NULL;
		chunk = curl_slist_append(chunk, hwid_header.c_str());
		chunk = curl_slist_append(chunk, "User-Agent: Argon Windows");
		chunk = curl_slist_append(chunk, "charset: utf-8");

		if (method.find("POST") != std::string::npos)
		{
			std::string length = "Content-Length: " + std::to_string(strlen(body.c_str()));

			chunk = curl_slist_append(chunk, "Accept: application/json");
			chunk = curl_slist_append(chunk, "Content-Type: application/json");
			chunk = curl_slist_append(chunk, length.c_str());

			curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
			curl_easy_setopt(curl, CURLOPT_POST, 1);
			curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());
			curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
			curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);
		}
		else
		{
			curl_easy_setopt(curl, CURLOPT_URL, url);
			curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
			curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
			curl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);
		}

		res = curl_easy_perform(curl);

		if (res != CURLE_OK)
		{
			RequestSuccess = false;
			fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
		}
		else
		{
			RequestSuccess = true;
		}

		curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &RequestStatusCode);

		curl_easy_cleanup(curl);
	}

	curl_global_cleanup();

	return readBuffer.c_str();
}

static size_t write_memory_callback(void* contents, size_t size, size_t nmemb, void* userp)
{
	size_t realsize = size * nmemb;
	struct MemoryStruct* mem = (struct MemoryStruct*)userp;

	char* ptr = (char*)realloc(mem->memory, mem->size + realsize + 1);
	if (ptr == NULL) {
		/* out of memory! */
		printf("not enough memory (realloc returned NULL)\n");
		return 0;
	}

	mem->memory = ptr;
	memcpy(&(mem->memory[mem->size]), contents, realsize);
	mem->size += realsize;
	mem->memory[mem->size] = 0;

	return realsize;
}

inline const char* HttpGethandle(const char* _curl)
{
	CURL* curl_handle;
	CURLcode res;

	struct MemoryStruct chunk;

	chunk.memory = (char*)malloc(1);
	chunk.size = 0;

	curl_global_init(CURL_GLOBAL_ALL);
	curl_handle = curl_easy_init();

	struct curl_slist* headers = NULL;
	headers = curl_slist_append(headers, "Accept: application/json");
	headers = curl_slist_append(headers, "Content-Type: application/json");
	headers = curl_slist_append(headers, "charset: utf-8");

	curl_easy_setopt(curl_handle, CURLOPT_URL, _curl);
	curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, headers);
	curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 1);
	curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, write_memory_callback);
	curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, reinterpret_cast<void*>(&chunk));
	curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");

	res = curl_easy_perform(curl_handle);

	if (res != CURLE_OK) {
		return nullptr;
	}

	curl_easy_cleanup(curl_handle);

	return chunk.memory;
}