#include <iostream>
#include <Windows.h>
#include <string>
#include <thread>
#include <vector>
#include <queue>
#include <map>

#include "Lua.hpp"
#include "API.hpp"
#include "XoR.h"


static lua_State* mainstate;


namespace Execution
{
	std::string gen_randomv2(const int len) {
		static const char alphanum[] =
			"0123456789"
			"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
			"abcdefghijklmnopqrstuvwxyz";
		std::string tmp_s;
		tmp_s.reserve(len);

		for (int i = 0; i < len; ++i) {
			tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
		}

		return tmp_s;
	}
	void execute(lua_State* mainstate, std::string source)
	{
		const auto Name = gen_randomv2(8);

		//Setting & Encoder
		encoder encoder;
		Luau::CompileOptions options{};
		options.coverageLevel = 0;
		options.debugLevel = 1;
		options.optimizationLevel = 1;

		lua_getglobal(mainstate, "spawn");
		std::string bytecode = Luau::compile("script = Instance.new('LocalScript'); script.Name = \"" + Name + "\";" + source, options, {}, &encoder);

		lua_State* newthread = lua_newthread(mainstate);
		thread_ref L = { newthread };

		if (luau_load(L.ref->state, std::string("=").append(Name).c_str(), bytecode.c_str(), bytecode.size(), 0))
		{
			lua_getglobal(mainstate, "warn");
			lua_pushstring(mainstate, bytecode.c_str() + 1);
			lua_pcall(mainstate, 1, 0, 0);
		}
		else
		{

			lua_newtable(mainstate);
			lua_pushvalue(mainstate, LUA_GLOBALSINDEX);
			lua_setfield(mainstate, -2, "__index");
			lua_setreadonly(mainstate, -1, true);
			lua_setmetatable(mainstate, -2);

			LuauCalls::scresume(taskscheduler->script_context(), L, 0);
		}
	}


	static int __fastcall scheduler_cycle(DWORD job, int a2, int call)
	{
		if (!coderun_queue.empty())
		{
			std::string script = coderun_queue.front();
			execute(mainstate, script);
			coderun_queue.pop();
		}

		return reinterpret_cast<int(__thiscall*)(int, int)>(job_cache)(job, call);
	}


	static void hook_scripts_job()
	{
		job_cache = taskscheduler->hook_job(taskscheduler->job_by_name("WaitingHybridScriptsJob"), scheduler_cycle);
	}

	auto loadstringc2(lua_State* rl) -> int
	{
		luaL_checktype(rl, 1, LUA_TSTRING);

		    const auto Name = gen_randomv2(8);
			encoder enc;
			const char* content = lua_tostring(rl, 1);

			Luau::CompileOptions options{};
			options.coverageLevel = 0;
			options.debugLevel = 1;
			options.optimizationLevel = 1;

			lua_getglobal(mainstate, "spawn");
			std::string bytecode = Luau::compile(content, options, {}, &enc);

			if (luau_load(rl, std::string("=").append(Name).c_str(), bytecode.data(), bytecode.length(), 0) == 0)
				return 1;

			lua_newtable(mainstate);
			lua_pushvalue(mainstate, LUA_GLOBALSINDEX);
			lua_setfield(mainstate, -2, "__index");
			lua_setreadonly(mainstate, -1, true);
			lua_setmetatable(mainstate, -2);

			lua_pushnil(rl);
			lua_insert(rl, -2);	

		return 2;
	}

	static void initialize()
	{
		curl_global_init(CURL_GLOBAL_ALL);
		mainstate = lua_newthread(reinterpret_cast<lua_State*>(taskscheduler->lua_state()));
		LuauIdentity::set(mainstate, 8);

		luaL_sandboxthread(mainstate);

		lua_newtable(mainstate);
		lua_setglobal(mainstate, "_G");

		lua_newtable(mainstate);
		lua_setglobal(mainstate, "shared");

		lua_pushboolean(mainstate, true);
		lua_setfield(mainstate, LUA_GLOBALSINDEX, "LOADED");

		lua_pushboolean(mainstate, true);
		lua_setfield(mainstate, LUA_GLOBALSINDEX, "IS_LOADED");

		//for lua functions 
		Registration::global(mainstate, "boolean31", API::Closures::boolean);
		//for lua functions

		Registration::global(mainstate, "getgenv", API::Env::getgenv);
		Registration::global(mainstate, "getreg", API::Env::getreg);
		Registration::global(mainstate, "getrenv", API::Env::getrenv);
		Registration::global(mainstate, "getgc", API::Env::getgc);

		Registration::global(mainstate, "getrawmetatable", API::Metatable::getrawmetatable);
		Registration::global(mainstate, "setrawmetatable", API::Metatable::setrawmetatable);
		Registration::global(mainstate, "getnamecallmethod", API::Metatable::getnamecallmethod);
		Registration::global(mainstate, "setnamecallmethod", API::Metatable::setnamecallmethod);
		Registration::global(mainstate, "isreadonly", API::Metatable::isreadonly);
		Registration::global(mainstate, "setreadonly", API::Metatable::setreadonly);
		Registration::global(mainstate, "make_writable", API::Metatable::make_writable);
		Registration::global(mainstate, "make_readonly", API::Metatable::make_readonly);
		Registration::global(mainstate, "makewritable", API::Metatable::make_writable);
		Registration::global(mainstate, "makereadonly", API::Metatable::make_readonly);
		Registration::global(mainstate, "identifyexecutor", API::Scripts::identifyexecutor);
		Registration::global(mainstate, "getexecutorname", API::Scripts::identifyexecutor);

		Registration::global(mainstate, "iscclosure", API::Closures::iscclosure);
		Registration::global(mainstate, "islclosure", API::Closures::islclosure);
		Registration::global(mainstate, "newcclosure", API::Closures::newcclosure); //needs hard fix
		Registration::global(mainstate, "hookfunction", API::Closures::hookfunction);
		Registration::global(mainstate, "replaceclosure", API::Closures::hookfunction);
		Registration::global(mainstate, "hookfunc", API::Closures::hookfunction);
		//Registration::global(mainstate, "hookmetamethod", API::Closures::hook_metamethod);
		Registration::global(mainstate, "loadstring", loadstringc2);
		Registration::global(mainstate, "clonefunction", API::Closures::clonefunction);
		Registration::global(mainstate, "checkcaller", API::Closures::checkcaller);
		Registration::global(mainstate, "isexecutorclosure", API::Closures::isexecutorclosure);
		Registration::global(mainstate, "checkclosure", API::Closures::isexecutorclosure);
		Registration::global(mainstate, "isourclosure", API::Closures::isexecutorclosure);
		Registration::global(mainstate, "is_argon_closure", API::Closures::isexecutorclosure);
		Registration::global(mainstate, "isscriptable", API::Closures::isscriptable);
		Registration::global(mainstate, "setscriptable", API::Closures::setscriptable);

		Registration::global(mainstate, "setclipboard", API::Scripts::setclipboard);
		Registration::global(mainstate, "toclipboard", API::Scripts::setclipboard);
		Registration::global(mainstate, "getscriptbytecode", API::Scripts::getscriptbytecode);
		Registration::global(mainstate, "getscriptclosure", API::Scripts::get_script_closure);
		Registration::global(mainstate, "HttpGet", API::Scripts::httpget);
		Registration::global(mainstate, "HttpGetAsync", API::Scripts::httpget);
		Registration::global(mainstate, "setfpscap", API::Scripts::setfpscap);
		Registration::global(mainstate, "request", API::Scripts::request);
		Registration::global(mainstate, "http_request", API::Scripts::request);

		lua_newtable(mainstate);
		Registration::member(mainstate, "request", API::Scripts::request);
		lua_setfield(mainstate, LUA_GLOBALSINDEX, "http");

		Registration::global(mainstate, "connectinit", API::Scripts::websocket_connect);

		Registration::global(mainstate, "cloneref", API::Scripts::cloneref);
		Registration::global(mainstate, "compareinstances", API::Scripts::compareinstances);
		Registration::global(mainstate, "getconnections", API::Scripts::get_connections);
		Registration::global(mainstate, "enableconnection", API::Scripts::connection_environment::enable_connection);
		Registration::global(mainstate, "disableconnection", API::Scripts::connection_environment::disable_connection);
		Registration::global(mainstate, "getthreadidentity", API::Scripts::getidentity);
		Registration::global(mainstate, "setthreadidentity", API::Scripts::setidentity);
		Registration::global(mainstate, "getidentity", API::Scripts::getidentity);
		Registration::global(mainstate, "setidentity", API::Scripts::setidentity);
		Registration::global(mainstate, "getthreadcontext", API::Scripts::getidentity);
		Registration::global(mainstate, "setthreadcontext", API::Scripts::setidentity);
		Registration::global(mainstate, "getproperties", API::Scripts::getproperties);
		Registration::global(mainstate, "setthreadcontext", API::Scripts::setidentity);
		Registration::global(mainstate, "getproperties", API::Scripts::getproperties);
		//Registration::global(mainstate, "getcustomasset", API::Scripts::getcustomasset); in lua for UNC Note: I guess roblox dont giving permission the FileSystem

		Registration::global(mainstate, "readfile", API::Filesystem::readfile);
		Registration::global(mainstate, "writefile", API::Filesystem::writefile);
		Registration::global(mainstate, "appendfile", API::Filesystem::appendfile);
		Registration::global(mainstate, "listfiles", API::Filesystem::listfiles);
		Registration::global(mainstate, "isfile", API::Filesystem::isfile);
		Registration::global(mainstate, "isfolder", API::Filesystem::isfolder);
		Registration::global(mainstate, "makefolder", API::Filesystem::makefolder);
		Registration::global(mainstate, "delfile", API::Filesystem::delfile);
		Registration::global(mainstate, "delfolder", API::Filesystem::delfolder);
		Registration::global(mainstate, "loadfile", API::Filesystem::loadfile); //lua
		Registration::global(mainstate, "dofile", API::Filesystem::dofile);

		Registration::global(mainstate, "isrbxactive", API::Input::isrbxactive);
		Registration::global(mainstate, "isgameactive", API::Input::isrbxactive);
		Registration::global(mainstate, "iswindowactive", API::Input::isrbxactive);
		Registration::global(mainstate, "mouse1click", API::Input::mouse1click);
		Registration::global(mainstate, "mouse1press", API::Input::mouse1press);
		Registration::global(mainstate, "mouse1release", API::Input::mouse1release);
		Registration::global(mainstate, "mouse2click", API::Input::mouse2click);
		Registration::global(mainstate, "mouse2press", API::Input::mouse2press);
		Registration::global(mainstate, "mouse2release", API::Input::mouse2release);
		Registration::global(mainstate, "mousemoveabs", API::Input::mousemoveabs);
		Registration::global(mainstate, "mousemoverel", API::Input::mousemoverel);
		Registration::global(mainstate, "mousescroll", API::Input::mousescroll);
		Registration::global(mainstate, "keypress", API::Input::keypress);
		Registration::global(mainstate, "keyrelease", API::Input::keyrelease);

		lua_newtable(mainstate);
		Registration::member(mainstate, "getinfo", API::Debug::debug_getinfo);
		Registration::member(mainstate, "getregistry", API::Env::getreg);
		Registration::member(mainstate, "getmetatable", API::Metatable::getrawmetatable);
		Registration::member(mainstate, "setmetatable", API::Metatable::setrawmetatable);
		Registration::member(mainstate, "getupvalue", API::Debug::debug_getupvalue);
		Registration::member(mainstate, "getupvalues", API::Debug::debug_getupvalues);
		Registration::member(mainstate, "setupvalue", API::Debug::debug_setupvalue);
		Registration::member(mainstate, "getconstant", API::Debug::debug_getconstant);
		Registration::member(mainstate, "getconstants", API::Debug::debug_getconstants);
		Registration::member(mainstate, "setconstant", API::Debug::debug_setconstant);
		Registration::member(mainstate, "getstack", API::Debug::debug_getstack);
		Registration::member(mainstate, "setstack", API::Debug::debug_setstack);
		Registration::member(mainstate, "getproto", API::Debug::debug_getproto);
		Registration::member(mainstate, "getprotos", API::Debug::debug_getprotos);
		lua_setfield(mainstate, LUA_GLOBALSINDEX, "debug");

		Registration::global(mainstate, "crypthash", API::crypt::crypt_hash);
		Registration::global(mainstate, "encrypt", API::crypt::crypt_encrypt);
		Registration::global(mainstate, "decrypt", API::crypt::crypt_decrypt);
		Registration::global(mainstate, "base64decode", API::crypt::crypt_base64decode);
		Registration::global(mainstate, "base64encode", API::crypt::crypt_base64encode);
		Registration::global(mainstate, "base64_decode", API::crypt::crypt_base64decode);
		Registration::global(mainstate, "base64_encode", API::crypt::crypt_base64encode);
		Registration::global(mainstate, "generatekey", API::crypt::crypt_generatekey);
		Registration::global(mainstate, "generatebytes", API::crypt::crypt_generatebytes);

		luaL_sandboxthread(mainstate);
		
		lua_getglobal(mainstate, "Instance");
		lua_getfield(mainstate, -1, "new");
		lua_pushstring(mainstate, "LocalScript");
		lua_pcall(mainstate, 1, 1, 0);
		
		lua_pushstring(mainstate, "LocalScript");
		lua_setfield(mainstate, -2, "Name");
		lua_setglobal(mainstate, "script");
		lua_settop(mainstate, 0);

		execute(mainstate, initscript);
		execute(mainstate, initscript2);
		execute(mainstate, drawinglib);
		//execute(mainstate, bitlib);
		//execute(mainstate, Jsonlib);
	}


	static void pipe()
	{
		DWORD bytes_read{};
		auto pipe_handle = CreateNamedPipeA("\\\\?\\pipe\\local\\hydrogen", PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, PIPE_WAIT, 1, 0, 0, NMPWAIT_USE_DEFAULT_WAIT, 0);
		while (pipe_handle != INVALID_HANDLE_VALUE)
		{
			if (ConnectNamedPipe(pipe_handle, 0))
			{
				std::string buffer(9999999999999999, '\0');
				while (ReadFile(pipe_handle, buffer.data(), buffer.length(), &bytes_read, 0))
				{
					buffer.resize(bytes_read);
				}
				coderun_queue.push(buffer);
			}
			DisconnectNamedPipe(pipe_handle);
		}
	}
}