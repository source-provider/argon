#include "ixwebsocket/IXWebSocket.h"
//#include "ixwebsocket/IXNetSystem.h" //giving error niga

#include <iostream>
#include <Windows.h>
#include <string>
#include <thread>
#include <vector>
#include <queue>
#include <map>

#include "TaskScheduler/TaskScheduler.hpp"
#include "sha384.h"
#include "sha256.h"
#include "sha512.h"
#include "request.h"

namespace API
{
	namespace Env
	{
		auto getgenv(lua_State* rl) -> int
		{
			lua_pushvalue(rl, LUA_ENVIRONINDEX);
			return 1;
		}


		auto getreg(lua_State* rl) -> int
		{
			lua_pushvalue(rl, LUA_REGISTRYINDEX);
			return 1;
		}


		auto getrenv(lua_State* rl) -> int
		{
			lua_pushvalue(reinterpret_cast<lua_State*>(taskscheduler->lua_state()), LUA_GLOBALSINDEX);
			lua_xmove(reinterpret_cast<lua_State*>(taskscheduler->lua_state()), rl, 1);
			return 1;
		}

		auto getgc(lua_State* state) -> int
		{
			const auto tables = lua_gettop(state) ? luaL_optboolean(state, 1, 0) : true;

			lua_newtable(state);

			struct gc_t
			{
				lua_State* state;
				const int tables;
				std::size_t count;
			} gct{ state, tables, 0 };

			luaM_visitgco(state, &gct, [](void* context, lua_Page* page, GCObject* gco)
				{
					const auto gct = static_cast<gc_t*>(context);

					if (!((gco->gch.marked ^ WHITEBITS) & otherwhite(gct->state->global)))
						return false;

					const auto tt = gco->gch.tt;

					if (tt == LUA_TFUNCTION || tt == LUA_TUSERDATA
						|| (gct->tables && tt == LUA_TTABLE))
					{
						gct->state->top->value.gc = gco;
						gct->state->top->tt = gco->gch.tt;
						gct->state->top++;

						lua_rawseti(gct->state, -2, ++gct->count);

					}

					return false;
				});

			return 1;
		}
	}


	namespace Metatable
	{
		auto getrawmetatable(lua_State* rl) -> int
		{
			lua_getmetatable(rl, 1);
			return 1;
		}


		auto setrawmetatable(lua_State* rl) -> int
		{
			lua_setmetatable(rl, 1);
			return 0;
		}


		auto getnamecallmethod(lua_State* rl) -> int
		{
			if (auto namecall = rl->namecall)
			{
				lua_pushstring(rl, namecall->data);
				return 1;
			}
			return 0;
		}


		auto setnamecallmethod(lua_State* rl) -> int
		{
			rl->namecall = reinterpret_cast<TString*>(index2addr(rl, 1)->value.p);
			return 0;
		}


		auto isreadonly(lua_State* rl) -> int
		{
			lua_pushboolean(rl, lua_getreadonly(rl, 1));
			return 1;
		}


		auto setreadonly(lua_State* rl) -> int
		{
			luaL_checktype(rl, 2, LUA_TBOOLEAN);
			lua_setreadonly(rl, 1, lua_toboolean(rl, 2));
			return 0;
		}


		auto make_writable(lua_State* rl) -> int
		{
			lua_setreadonly(rl, 1, false);
			return 0;
		}


		auto make_readonly(lua_State* rl) -> int
		{
			lua_setreadonly(rl, 1, true);
			return 0;
		}
	}


	namespace Closures
	{
		auto iscclosure(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			lua_pushboolean(rl, lua_iscfunction(rl, 1));
			return 1;
		}


		auto islclosure(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			lua_pushboolean(rl, lua_isLfunction(rl, 1));
			return 1;
		}

		auto boolean(lua_State* rl) -> int
		{
			lua_pushboolean(rl, true);
			return 1;
		}

		static int newcclosure_handler(lua_State* rl)
		{
			const auto oargs = lua_gettop(rl);
			const auto closure = Handler::nccmap.find(clvalue(rl->ci->func))->second;
			const auto top = rl->top;

			top->value.p = reinterpret_cast<void*>(closure);
			top->tt = LUA_TFUNCTION;
			rl->top++;

			lua_insert(rl, 1);

			const char* error;
			const auto res = lua_pcall(rl, oargs, LUA_MULTRET, 0);

			if (res && res != LUA_YIELD && (error = luaL_checklstring(rl, -1, nullptr), !std::strcmp(error, "attempt to yield across metamethod/C-call boundary")))
				return lua_yield(rl, 0);

			return lua_gettop(rl);
		}

		static int newcclosure(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			lua_ref(rl, 1);

			Closure* lclosure = *reinterpret_cast<Closure**>(index2addr(rl, 1));
			Handler::push(rl, newcclosure_handler, nullptr, 0);
			Closure* cclosure = *reinterpret_cast<Closure**>(index2addr(rl, -1));

			Handler::wraps::set(cclosure, lclosure);
			return 1;
		}

		static type get_type(Closure* cl)
		{
			auto cl_type = not_set;

			if (!cl->isC)
				cl_type = l_closure;
			else
			{
				if (reinterpret_cast<lua_CFunction>((lua_CFunction)cl->c.f) == Handler::retcheck_jmp)
				{
					if (Handler::get(cl) == newcclosure_handler)
						cl_type = module_c_wrap;
					else
						cl_type = module_c_closure;
				}
				else
					cl_type = roblox_c_closure;
			}

			return cl_type;
		}

		static int hookfunction(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);
			luaL_checktype(rl, 2, LUA_TFUNCTION);

			const auto cl1 = clvalue(index2addr(rl, 1));
			const auto cl2 = clvalue(index2addr(rl, 2));
			int nups1 = cl1->nupvalues;
			int nups2 = cl2->nupvalues;

			if (get_type(cl1) == roblox_c_closure && get_type(cl2) == roblox_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);

					cl1->c.f = (lua_CFunction)cl2->c.f;
					cl1->c.cont = (lua_Continuation)cl2->c.cont;
					cl1->env = (Table*)cl2->env;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == module_c_closure && get_type(cl2) == module_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);
					Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));

					Handler::set(cl1, Handler::get(cl2));
					cl1->c.cont = (lua_Continuation)cl2->c.cont;
					cl1->env = (Table*)cl2->env;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == module_c_wrap && get_type(cl2) == module_c_wrap)
			{
				lua_clonecfunction(rl, 1);
				Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));

				Handler::wraps::set(clvalue(index2addr(rl, -1)), Handler::wraps::get(cl1));
				Handler::wraps::set(cl1, Handler::wraps::get(cl2));

				cl1->env = (Table*)cl2->env;
			}

			else if (get_type(cl1) == l_closure && get_type(cl2) == l_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonefunction(rl, 1);

					cl1->l.p = (Proto*)cl2->l.p;
					cl1->env = (Table*)cl2->env;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->l.uprefs[i], &cl2->l.uprefs[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == roblox_c_closure && get_type(cl2) == module_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);

					Handler::set(cl1, Handler::get(cl2));

					cl1->c.f = (lua_CFunction)cl2->c.f;
					cl1->c.cont = (lua_Continuation)cl2->c.cont;
					cl1->env = (Table*)cl2->env;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == roblox_c_closure && get_type(cl2) == module_c_wrap)
			{
				lua_clonecfunction(rl, 1);

				Handler::set(cl1, Handler::get(cl2));
				Handler::wraps::set(cl1, Handler::wraps::get(cl2));

				cl1->c.f = (lua_CFunction)cl2->c.f;
				cl1->c.cont = (lua_Continuation)cl2->c.cont;
				cl1->env = (Table*)cl2->env;
			}

			else if (get_type(cl1) == roblox_c_closure && get_type(cl2) == l_closure)
			{
				lua_clonecfunction(rl, 1);
				lua_ref(rl, 2);

				cl1->c.f = (lua_CFunction)Handler::retcheck_jmp;
				Handler::set(cl1, newcclosure_handler);
				Handler::wraps::set(cl1, cl2);
			}

			else if (get_type(cl1) == module_c_closure && get_type(cl2) == roblox_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);
					Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));

					cl1->env = (Table*)cl2->env;
					cl1->c.f = (lua_CFunction)cl2->c.f;
					cl1->c.cont = (lua_Continuation)cl2->c.cont;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == module_c_closure && get_type(cl2) == module_c_wrap)
			{
				lua_clonecfunction(rl, 1);
				Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));

				Handler::set(cl1, newcclosure_handler);
				Handler::wraps::set(cl1, cl2);
			}

			else if (get_type(cl1) == module_c_closure && get_type(cl2) == l_closure)
			{
				lua_clonecfunction(rl, 1);
				Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));
				lua_ref(rl, 2);

				Handler::set(cl1, newcclosure_handler);
				Handler::wraps::set(cl1, cl2);
			}

			else if (get_type(cl1) == module_c_wrap && get_type(cl2) == roblox_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);
					Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));
					Handler::wraps::set(clvalue(index2addr(rl, -1)), Handler::wraps::get(cl1));

					cl1->env = (Table*)cl2->env;
					cl1->c.f = (lua_CFunction)cl2->c.f;
					cl1->c.cont = (lua_Continuation)cl2->c.cont;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == module_c_wrap && get_type(cl2) == module_c_closure)
			{
				if (nups1 >= nups2)
				{
					lua_clonecfunction(rl, 1);
					Handler::set(clvalue(index2addr(rl, -1)), Handler::get(cl1));
					Handler::wraps::set(clvalue(index2addr(rl, -1)), Handler::wraps::get(cl1));

					Handler::set(cl1, Handler::get(cl2));

					cl1->env = (Table*)cl2->env;
					cl1->c.cont = (lua_Continuation)cl2->c.cont;

					for (int i = 0; i < nups2; i++)
						setobj2n(rl, &cl1->c.upvals[i], &cl2->c.upvals[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}

			else if (get_type(cl1) == l_closure && (get_type(cl2) == roblox_c_closure || get_type(cl2) == module_c_closure))
			{
				lua_clonefunction(rl, 1);
				const auto& spoof = Luau::compile("local f = function() end; return f(...); ");
				luau_load(rl, cl1->l.p->source->data, spoof.c_str(), spoof.size(), 0);

				Closure* clspoof = clvalue(index2addr(rl, -1));
				setobj(rl, &clspoof->l.p->k[0], index2addr(rl, 2));
				clspoof->l.p->linedefined = (int)cl1->l.p->linedefined;
				cl1->l.p = (Proto*)clspoof->l.p;

				lua_pop(rl, 1);
			}

			else if (get_type(cl1) == l_closure && get_type(cl2) == module_c_wrap)
			{
				const Closure* l = Handler::wraps::get(cl2);

				if (nups1 >= l->nupvalues)
				{
					lua_clonefunction(rl, 1);

					cl1->env = (Table*)l->env;
					cl1->l.p = (Proto*)l->l.p;

					for (int i = 0; i < l->nupvalues; i++)
						setobj2n(rl, &cl1->l.uprefs[i], &l->l.uprefs[i]);
				}
				else
					luaL_error(rl, "hookfunction - too many upvalues");
			}
			else
				luaL_error(rl, "hookfunction - unsupported closure pair");

			return 1;
		}

		int hook_metamethod(lua_State* state)
		{
			if (!lua_isuserdata(state, 1) && !lua_istable(state, 1))
				luaL_argerror(state, 1, "hookmetamethod - expected table or userdata (FIRST ARG)");

			/*
			hookmetamethod takes one argument, which is the object to be modified.
			It then retrieves the second argument from the stack, which is the name of the method to be hooked, and checks that it is a string.
			*/
			const auto metamethod = luaL_checklstring(state, 2, nullptr);

			/* It then retrieves the third argument from the stack, which is the function to be used as the hook, and checks that it is a function. */
			luaL_checktype(state, 3, LUA_TFUNCTION);

			lua_getfield(state, -10002, "hookfunction");

			/*
			then, hookmetamethod retrieves the metatable associated with the object and gets the metafield with the name of the method to be hooked.
			If the metafield is not found, the function raises an error.
			*/

			if (!luaL_getmetafield(state, 1, metamethod))
				luaL_error(state, "hookmetamethod - metatable for instance could not be found");

			/* then it pushes the hook function to the stack and calls the hookfunction with the metafield and hook function. */
			lua_pushvalue(state, 3);
			lua_pcall(state, 2, 1, 0);
			return 1;
		}

		auto loadstring(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TSTRING);

			encoder enc;
			std::string content = lua_tostring(rl, 1);
			Luau::CompileOptions options{};
			options.coverageLevel = 0;
			options.debugLevel = 1;
			options.optimizationLevel = 1;
			std::string bytecode = Luau::compile(content, options, {}, &enc);

			if (luau_load(rl, "", bytecode.data(), bytecode.length(), 0) == 0)
				return 1;

			lua_pushnil(rl);
			lua_insert(rl, -2);
			return 2;
		}


		static int clonefunction(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			switch (get_type(clvalue(index2addr(rl, 1))))
			{
			case roblox_c_closure:
				lua_clonecfunction(rl, 1);
				break;
			case module_c_closure:
				lua_clonecfunction(rl, 1);
				Handler::set(clvalue(index2addr(rl, -1)), Handler::get(clvalue(index2addr(rl, 1))));
				break;
			case module_c_wrap:
				lua_clonecfunction(rl, 1);
				Handler::set(clvalue(index2addr(rl, -1)), Handler::get(clvalue(index2addr(rl, 1))));
				Handler::wraps::set(clvalue(index2addr(rl, -1)), Handler::wraps::get(clvalue(index2addr(rl, 1))));
				break;
			case l_closure:
				lua_clonefunction(rl, 1);
				break;
			}

			return 1;
		}


		static int isexecutorclosure(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			auto function = clvalue(index2addr(rl, 1));

			if (lua_iscfunction(rl, 1))
			{
				lua_pushboolean(rl, function->c.f == Handler::cfunction_handler);
			}
			else
			{
				lua_pushboolean(rl, function->l.p->linedefined);
			}
			return 1;
		}

		static int checkcaller(lua_State* rl)
		{
			lua_pushboolean(rl, LuauIdentity::get(rl));
			return 1;
		}

		static int isscriptable(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);
			luaL_checktype(rl, 2, LUA_TSTRING);

			uintptr_t instance = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			std::string property_name = lua_tostring(rl, 2);

			for (uintptr_t property : *reinterpret_cast<std::vector<uintptr_t>*>(*reinterpret_cast<uintptr_t*>(instance + 12) + 24))
			{
				std::string name = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(property + 4));
				if (property_name == name)
				{
					bool isscriptable = (bool)(*reinterpret_cast<int*>(property + 32) > 32);
					lua_pushboolean(rl, isscriptable);
					return 1;
				}
			}
			return 0;
		}


		static int setscriptable(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);
			luaL_checktype(rl, 2, LUA_TSTRING);
			luaL_checktype(rl, 3, LUA_TBOOLEAN);

			uintptr_t instance = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			std::string property_name = lua_tostring(rl, 2);
			bool enabled = lua_toboolean(rl, 3);

			for (uintptr_t property : *reinterpret_cast<std::vector<uintptr_t>*>(*reinterpret_cast<uintptr_t*>(instance + 12) + 24))
			{
				std::string name = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(property + 4));
				if (property_name == name)
				{
					bool isscriptable = (bool)(*reinterpret_cast<int*>(property + 32) > 32);
					*reinterpret_cast<int*>(property + 32) = (enabled ? 33 : 30);
					lua_pushboolean(rl, isscriptable);
					return 1;
				}
			}
			return 0;
		}
	}


	namespace Scripts
	{

		auto identifyexecutor(lua_State* rl) -> int
		{
			lua_pushstring(rl, "Argon");
			lua_pushstring(rl, "1.0.0");
			return 2;
		}


		auto setclipboard(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TSTRING);

			size_t l = 0;
			auto s = luaL_checklstring(rl, 1, &l);
			std::string content = std::string(s, l);

			HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, l + 1);
			memcpy(GlobalLock(hMem), content.data(), l);
			GlobalUnlock(hMem);
			OpenClipboard(0);
			EmptyClipboard();
			SetClipboardData(CF_TEXT, hMem);
			CloseClipboard();
			return 0;
		}

		auto getclipboard(lua_State* rl) -> int
		{
			OpenClipboard(NULL);
			HANDLE hData = GetClipboardData(CF_TEXT);
			char* pszText = (char*)GlobalLock(hData);
			char* pszTextCopy = (char*)malloc(GlobalSize(hData) + 1);
			//strcpy(pszTextCopy, pszText);
			GlobalUnlock(hData);
			CloseClipboard();
			lua_pushstring(rl, pszTextCopy);
			return 1;
		}

		auto getscriptbytecode(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			uintptr_t script = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			uintptr_t descriptor = *reinterpret_cast<uintptr_t*>(script + 12);
			const char* classname = *reinterpret_cast<const char**>(descriptor + 4);
			std::string compressed_bytecode;

			if (strcmp(classname, "LocalScript") == 0)
				compressed_bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(script + Offsets::Bytecode::localscript) + 16);
			else if (strcmp(classname, "ModuleScript") == 0)
				compressed_bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(script + Offsets::Bytecode::modulescript) + 16);
			else
				luaL_error(rl, "unsupported type.");

			std::string bytecode = Compression::decompress(compressed_bytecode);
			if (bytecode.at(0) == 0)
				luaL_error(rl, "invalid bytecode.");

			lua_pushstring(rl, bytecode.data());
			return 1;
		}

		int get_script_closure(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			uintptr_t script = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			uintptr_t descriptor = *reinterpret_cast<uintptr_t*>(script + 12);
			const char* classname = *reinterpret_cast<const char**>(descriptor + 4);
			std::string compressed_bytecode;

			if (strcmp(classname, "LocalScript") == 0)
				compressed_bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(script + Offsets::Bytecode::localscript) + 16);
			else if (strcmp(classname, "ModuleScript") == 0)
				compressed_bytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<uintptr_t*>(script + Offsets::Bytecode::modulescript) + 16);
			else
				luaL_error(rl, "unsupported type.");

			std::string bytecode = Compression::decompress(compressed_bytecode);
			if (bytecode.at(0) == 0)
				luaL_error(rl, "invalid bytecode.");

			luau_load(rl, "@Argon", bytecode.c_str(), bytecode.length(), 0);
			return 1;
		}

		auto getscripthash(lua_State* rl) -> int
		{
			uintptr_t script = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			uintptr_t descriptor = *reinterpret_cast<uintptr_t*>(script + 12);
			const char* classname = *reinterpret_cast<const char**>(descriptor + 4);

			std::string hold = script + ":GetHash()";
			lua_tostring(rl, (int)hold.c_str());

			return 1;
		}


		auto httpget(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TSTRING);

			std::string content = HttpGethandle(lua_tostring(rl, 1));
			lua_pushlstring(rl, content.c_str(), content.size());
			return 1;
		}


		std::string http_request1(const std::string& url) {
			std::string response;

			HINTERNET hInternet = InternetOpen("HTTP Client", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
			if (hInternet == NULL) {
				// Failed to open Internet handle
				return response;
			}

			std::unique_ptr<char[]> urlBuffer(new char[url.size() + 1]);
			strncpy_s(urlBuffer.get(), url.size() + 1, url.c_str(), url.size());

			HINTERNET hConnect = InternetOpenUrlA(hInternet, urlBuffer.get(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
			if (hConnect == NULL) {
				// Failed to open URL
				InternetCloseHandle(hInternet);
				return response;
			}

			constexpr DWORD BufferSize = 4096;
			std::vector<char> buffer(BufferSize);
			DWORD bytesRead = 0;
			while (InternetReadFile(hConnect, buffer.data(), BufferSize, &bytesRead) && bytesRead > 0) {
				response.append(buffer.data(), bytesRead);
			}

			InternetCloseHandle(hConnect);
			InternetCloseHandle(hInternet);

			return response;
		}

		int http_request(lua_State* L) {
			const char* url = luaL_checkstring(L, 1);
			std::string response = http_request1(url);

			lua_pushstring(L, response.c_str());
			return 1;
		}

		auto httpgethandle(lua_State* state) -> int
		{
			lua_getfield(state, -10002, "game");
			lua_getfield(state, -1, "HttpGetAsync");

			lua_pushvalue(state, 1);
			lua_pushvalue(state, 2);
			return 1;
		}

		auto getobjects(lua_State* state) -> int
		{
			lua_settop(state, 0);
			lua_getfield(state, -10002, "game");
			lua_getfield(state, -1, "GetService");
			lua_pushvalue(state, -2);
			lua_pushstring(state, "InsertService");
			lua_pcall(state, 2, 1, 0);
			lua_getfield(state, -1, "LoadLocalAsset");
			lua_pushvalue(state, -2);
			lua_pushvalue(state, 2);
			lua_pcall(state, 2, 1, 0);
			lua_createtable(state, 0, 0);
			lua_pushvalue(state, -2);
			lua_rawseti(state, -2, 1);

			return 1; //Semi working idk
		}

		__forceinline std::uintptr_t get_base()
		{
			static const auto base = reinterpret_cast<std::uintptr_t>(GetModuleHandleA(nullptr));
			return base;
		}
		template<typename ret, typename arg>
		__forceinline ret unbase(arg address, std::uintptr_t to_base = 0x400000)
		{
			return ret(address - to_base + get_base());
		}

		void* pushinstance = unbase<void*>(0x7A2B40);

		static int invalidate(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			lua_pushlightuserdata(rl, reinterpret_cast<void*>(pushinstance));
			lua_rawget(rl, -10000);
			lua_pushlightuserdata(rl, reinterpret_cast<void*>(lua_touserdata(rl, 1)));

			lua_pushnil(rl);
			lua_rawset(rl, -3);
			return 0;
		}


		static int iscached(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			uintptr_t object = *reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(lua_touserdata(rl, 1)));

			lua_pushlightuserdata(rl, reinterpret_cast<void*>(pushinstance));
			lua_rawget(rl, LUA_REGISTRYINDEX);
			lua_pushlightuserdata(rl, reinterpret_cast<void*>(object));
			lua_rawget(rl, -2);

			lua_pushboolean(rl, !lua_isnil(rl, -1));
			return 1;
		}


		static int replace(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			uintptr_t object = *reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(lua_touserdata(rl, 1)));

			lua_pushlightuserdata(rl, reinterpret_cast<void*>(pushinstance));
			lua_rawget(rl, LUA_REGISTRYINDEX);
			lua_pushlightuserdata(rl, reinterpret_cast<void*>(object));

			lua_pushvalue(rl, 2);
			lua_rawset(rl, -3);
			return 0;
		}

		static int cloneref(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);

			const auto instance = uvalue(index2addr(rl, 1));
			lua_newuserdatatagged(rl, instance->len, instance->tag);
			const auto new_instance = uvalue(index2addr(rl, -1));
			new_instance->metatable = (Table*)instance->metatable;

			*reinterpret_cast<std::uintptr_t*>(new_instance->data) = *reinterpret_cast<std::uintptr_t*>(instance->data);
			new_instance->dummy.u = instance->dummy.u;

			return 1;
		}

		static int compareinstances(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TUSERDATA);
			luaL_checktype(rl, 2, LUA_TUSERDATA);

			uintptr_t instance_one = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 1));
			uintptr_t instance_two = *reinterpret_cast<uintptr_t*>(lua_touserdata(rl, 2));

			lua_pushboolean(rl, instance_one == instance_two);
			return 1;
		}

		auto setfpscap(lua_State* rl) -> int
		{
			luaL_checktype(rl, 1, LUA_TNUMBER);

			auto fps = lua_tonumber(rl, 1);

			if (fps <= 0)
				taskscheduler->set_fps(100);
			else
				taskscheduler->set_fps(fps);

			return 0;
		}

		const auto rbxscriptsignal_scriptconnection = 0x1C;
		const auto rbxscriptsignal_nextsignal = 0x10;
		const auto rbxscriptsignal_state = 0x14;



		namespace connection_environment
		{
			struct connections
			{
				std::uintptr_t Object;
				std::uintptr_t OldState;
			};

			std::unordered_map<std::uintptr_t, connections> Connections;

			int enable_connection(lua_State* rL)
			{
				const auto Signal = *(DWORD*)lua_touserdata(rL, 1);//*reinterpret_cast<std::uintptr_t*>(r_lua_touserdata(rL, 1));

				if (!Connections.count(Signal))
				{
					connections New;
					New.Object = Signal;
					New.OldState = *reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state);

					Connections[Signal] = New;
				}

				*reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state) = Connections[Signal].OldState;
				return 0;
			}

			int disable_connection(lua_State* rL)
			{
				const auto Signal = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(rL, 1));

				if (!Connections.count(Signal))
				{
					connections New;
					New.Object = Signal;
					New.OldState = *reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state);

					Connections[Signal] = New;
				}

				*reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state) = 0;
				return 0;
			}


			int blank_function(lua_State* rL)
			{
				return 0;
			}

			std::int32_t index_connection(lua_State* rL)
			{
				const std::string Key = lua_tolstring(rL, 2, nullptr);

				if (Key == "Enable" || Key == "enable")
				{
					lua_pushvalue(rL, 1);
					lua_pushcfunction(rL, enable_connection, 0);
				}
				else if (Key == "Function" || Key == "function" || Key == "Fire" || Key == "fire")
				{
					const auto connection = *reinterpret_cast<connections*>(lua_touserdata(rL, 1));
					lua_pushnumber(rL, *reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<std::uintptr_t*>(*reinterpret_cast<std::uintptr_t*>(connection.Object + rbxscriptsignal_scriptconnection) + 0x64) + 0xC));
					lua_rawget(rL, LUA_REGISTRYINDEX);

					if (lua_type(rL, -1) <= 0)
						lua_pushcfunction(rL, blank_function, 0);
				}
				else if (Key == "Enabled" || Key == "enabled" || Key == "ForeignState" || Key == "LuaConnection")
				{
					const auto Signal = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(rL, 1));

					const auto conn = *reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state);

					lua_pushboolean(rL, conn);
					//*reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state) = 0;
				}
				else if (Key == "Thread")
				{
					lua_pushthread(rL);
				}
				else
				{
					lua_pushvalue(rL, 1);
					lua_pushcfunction(rL, disable_connection, 0);
				}

				return 1;
			}
		}

		int getidentity(lua_State* state)
		{
			lua_pushinteger(state, LuauIdentity::get(state));
			return 1;
		}

		int setidentity(lua_State* state)
		{
			int identity = lua_tonumber(state, 1);

			LuauIdentity::set(state, identity); // set the current context level.
			return 0;
		}

		int getproperties(lua_State* state)
		{
			if (lua_gettop(state) < 1)
				luaL_error(state, "1 argument expected");

			if (lua_type(state, 1) == LUA_TUSERDATA)
			{
				const auto instance = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(state, 1));
				const auto class_descriptor = *reinterpret_cast<std::uintptr_t*>(instance + 0xC);

				lua_createtable(state, 0, 0);

				const auto start = *reinterpret_cast<std::uintptr_t*>(class_descriptor + 0x24);
				const auto end = *reinterpret_cast<std::uintptr_t*>(class_descriptor + 0x28);

				int iteration = 0u;

				for (auto i = start; i < end; i += 8)
				{
					const char* prop_name = *reinterpret_cast<const char**>(i);

					if (prop_name != nullptr && strlen(prop_name) > 0)
					{
						lua_pushinteger(state, ++iteration);
						lua_pushstring(state, prop_name);
						lua_settable(state, -3);
					}
				}

				return 1;
			}

			return 0;
		}

		std::string get_roblox_path()
		{
			char path[MAX_PATH];
			GetModuleFileNameA(GetModuleHandleA(0), path, sizeof(path));
			return std::filesystem::path(path).parent_path().string();
		}

		void create_asset_directory()
		{
			auto roblox_path = std::filesystem::path(get_roblox_path()) / "content" / "TrxQ";
			if (!std::filesystem::exists(roblox_path))
			{
				std::filesystem::create_directory(roblox_path);
			}
		} 
		
		std::string get_dll_path(const char* Addon)
		{
			HMODULE hModule = GetModuleHandleW(std::wstring(L"hydrogen-ms.dll").c_str());

			if (hModule == NULL)
				throw std::exception("Failed to grab module handle! (GETDLLPATH)");

			char buffer[MAX_PATH + 1];
			GetModuleFileNameA(hModule, buffer, MAX_PATH);

			std::string::size_type pos = std::string(buffer).find_last_of("\\/");
			return std::string(buffer).substr(0, pos).append(Addon);
		}

		int getcustomasset(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			auto workspace = std::filesystem::path(get_dll_path("\\workspace").append("\\")) / lua_tostring(state, 1);
			auto custom_asset = std::filesystem::path(get_roblox_path()) / "content" / workspace.filename();
		//	std::filesystem::copy_file(workspace, custom_asset, std::filesystem::copy_options::update_existing);

			lua_pushstring(state, std::string("rbxasset://" + custom_asset.filename().string()).data());
			return 1;
		}

		int get_connections(lua_State* rL)
		{
			//const auto R_LUA_TUSERDATA = r_get_offset(r_offsets::R_LUAT_USERDATA);

			luaL_checktype(rL, 1, LUA_TUSERDATA);



			lua_getfield(rL, 1, "connect");
			lua_pushvalue(rL, 1);
			lua_pushcfunction(rL, connection_environment::blank_function, 0);
			lua_pcall(rL, 2, 1, 0);

			const auto signal = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(rL, -1));
			auto next = *reinterpret_cast<std::uintptr_t*>(signal + rbxscriptsignal_nextsignal);

			//r_lua_createtable(rL, 0, 0);
			lua_createtable(rL, 0, 0);
			auto Count = 1;

			while (next != 0)
			{

				if (connection_environment::Connections.count(next))
				{
					*reinterpret_cast<connection_environment::connections*>(lua_newuserdata(rL, sizeof(connection_environment::connections), 0)) = connection_environment::Connections[next];

					//r_lua_createtable(rL, 0, 0);
					lua_createtable(rL, 0, 0);
					lua_pushcfunction(rL, connection_environment::index_connection, 0);
					lua_setfield(rL, -2, "__index");
					lua_pushstring(rL, "table");
					lua_setfield(rL, -2, "__type");
					lua_setmetatable(rL, -2);
				}
				else
				{
					connection_environment::connections new_connection;
					new_connection.Object = next;
					new_connection.OldState = *reinterpret_cast<std::uintptr_t*>(next + rbxscriptsignal_state);

					*reinterpret_cast<connection_environment::connections*>(lua_newuserdata(rL, sizeof(connection_environment::connections), 0)) = new_connection;

					lua_createtable(rL, 0, 0);
					//r_lua_newtable(rL);
					lua_pushcfunction(rL, connection_environment::index_connection, 0);
					lua_setfield(rL, -2, "__index");
					lua_pushstring(rL, "table");
					lua_setfield(rL, -2, "__type");
					lua_setmetatable(rL, -2);

					connection_environment::Connections[next] = new_connection;
				}

				lua_rawseti(rL, -2, Count++);
				next = *reinterpret_cast<std::uintptr_t*>(next + rbxscriptsignal_nextsignal);
			}

			lua_getfield(rL, -2, "Disconnect");
			lua_pushvalue(rL, -3);
			lua_pcall(rL, 1, 0, 0);

			return 1;
		}

		std::int32_t websockettools(lua_State* rL)
		{
			const std::string Key = lua_tolstring(rL, 2, nullptr);
			ix::WebSocket webSocket;

			if (Key == "Send" || Key == "send")
			{
				std::string send(lua_tostring(rL, 1));
				webSocket.send(send);
				return 1;
			}
			else if (Key == "Close" || Key == "close")
			{
				webSocket.close();
				return 1;
			}
			else if (Key == "OnMessage" || Key == "Onmessage" || Key == "onmessage" || Key == "OnClose" || Key == "onclose")
			{
				const auto Signal = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(rL, 1));

				const auto conn = *reinterpret_cast<std::uintptr_t*>(Signal + rbxscriptsignal_state);

				lua_pushboolean(rL, conn);
				return 1;
			}
			else
			{
				webSocket.close();
				return 1;
			}

			return 1;
		}
		

		int close_function(lua_State* rL)
		{
			ix::WebSocket webSocket;
			webSocket.close();
			return 0;
		}

		int websocket_connect(lua_State* rL)
		{
			//ix::initNetSystem();

			ix::WebSocket webSocket;

			std::string url(lua_tostring(rL, 1));
			webSocket.setUrl(url);

			lua_createtable(rL, 0, 0);
			lua_newtable(rL);
			lua_pushcfunction(rL, websockettools, 0);
			lua_setfield(rL, -2, "__index");
			lua_pushstring(rL, "table");
			lua_setfield(rL, -2, "__type");
			lua_setmetatable(rL, -2);

			webSocket.start();
			return 1;
		}

		int request(lua_State* rL)
		{
			std::string url = "";
			std::string method = "";
			std::string body = "";

			lua_getfield(rL, 1, "Url");
			if (lua_type(rL,  -1) == LUA_TSTRING)
			{
				url = lua_tostring(rL, -1);
			}
			else
			{
				lua_pushnil(rL);
				return 1;
			}
			lua_pop(rL, 1);

			lua_getfield(rL, 1, "Method");
			if (lua_type(rL, -1) == LUA_TSTRING)
			{
				method = lua_tostring(rL, -1);
			}
			else
			{
				lua_pushnil(rL);
				return 1;
			}
			lua_pop(rL, 1);

			std::transform(method.begin(), method.end(), method.begin(), ::toupper);

			if (method == "POST")
			{
				lua_getfield(rL, 1, "Body");
				if (lua_type(rL, -1) == LUA_TSTRING)
				{
					body = lua_tostring(rL, -1);
				}
				else
				{
					lua_pushnil(rL);
					return 1;
				}
				lua_pop(rL, 1);
			}

			if (url != "" && method != "")
			{
				const char* request_return = Request(url.c_str(), method.c_str(), body.c_str());

				lua_newtable(rL);
				lua_pushstring(rL, request_return);
				lua_setfield(rL, -2, "Body");
				lua_pushboolean(rL, RequestSuccess);
				lua_setfield(rL, -2, "Success");
				lua_pushinteger(rL, RequestStatusCode);
				lua_setfield(rL, -2, "StatusCode");

				RequestSuccess = false;
				RequestStatusCode = 0;

				return 1;
			}
			else
			{

				lua_pushnil(rL);
				return 1;
			}

			return 1;
		}
	}

	namespace crypt
	{
		namespace Tools
		{
			enum Hash
			{
				HashSha1, HashMd5, HashSha256
			};

			bool RequestSuccess = false;
			int RequestStatusCode = 0;

			std::string ReplaceAll(std::string str, const std::string& from, const std::string& to)
			{
				size_t start_pos = 0;
				while ((start_pos = str.find(from, start_pos)) != std::string::npos)
				{
					str.replace(start_pos, from.length(), to);
					start_pos += to.length();
				}
				return str;
			}

			const uint8_t ToByte(std::string str, const size_t offset = 0)
			{
				uint8_t b, n = 0;

				if (str[offset] == '?' && str[offset + 1] == '?')
					return n;

				for (int i = offset; i < offset + 2; b = 0, i++)
				{
					if (str[i] >= 0x61)
						b = str[i] - 0x57;
					else if (str[i] >= 0x41)
						b = str[i] - 0x37;
					else if (str[i] >= 0x30)
						b = str[i] - 0x30;

					if (i == offset)
						n += (b * 16);
					else {
						n += b;
					}
				}

				return n;
			}

			size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
			{
				((std::string*)userp)->append((char*)contents, size * nmemb);
				return size * nmemb;
			}

			std::string GenerateHash(const void* data, const size_t data_size, Hash hashType)
			{
				HCRYPTPROV hProv = NULL;

				if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
				{
					return "";
				}

				BOOL hash_ok = FALSE;
				HCRYPTPROV hHash = NULL;

				switch (hashType)
				{
				case HashSha1:
					hash_ok = CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash);
					break;
				case HashMd5:
					hash_ok = CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash);
					break;
				case HashSha256:
					hash_ok = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash);
					break;
				}

				if (!hash_ok)
				{
					CryptReleaseContext(hProv, 0);
					return "";
				}

				if (!CryptHashData(hHash, static_cast<const BYTE*>(data), data_size, 0))
				{
					CryptDestroyHash(hHash);
					CryptReleaseContext(hProv, 0);
					return "";
				}

				DWORD cbHashSize = 0, dwCount = sizeof(DWORD);

				if (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&cbHashSize, &dwCount, 0))
				{
					CryptDestroyHash(hHash);
					CryptReleaseContext(hProv, 0);
					return "";
				}

				std::vector<BYTE> buffer(cbHashSize);

				if (!CryptGetHashParam(hHash, HP_HASHVAL, reinterpret_cast<BYTE*>(&buffer[0]), &cbHashSize, 0))
				{
					CryptDestroyHash(hHash);
					CryptReleaseContext(hProv, 0);
					return "";
				}

				std::ostringstream oss;

				for (std::vector<BYTE>::const_iterator iter = buffer.begin(); iter != buffer.end(); ++iter)
				{
					oss.fill('0');
					oss.width(2);
					oss << std::hex << static_cast<const int>(*iter);
				}

				CryptDestroyHash(hHash);
				CryptReleaseContext(hProv, 0);
				return oss.str();
			}
		}


		std::string encrypt(std::string plaintext, int key) {
			std::string ciphertext = "";
			for (int i = 0; i < plaintext.length(); i++) {
				char c = plaintext[i];
				// Encrypt the character using the key
				c = (c + key) % 256;
				ciphertext += c;
			}
			return ciphertext;
		}

		std::string decrypt(std::string ciphertext, int key) {
			std::string plaintext = "";
			for (int i = 0; i < ciphertext.length(); i++) {
				char c = ciphertext[i];
				// Decrypt the character using the key
				c = (c - key) % 256;
				plaintext += c;
			}
			return plaintext;
		}


		int crypt_encrypt(lua_State* rl)
		{

			const auto& encryptd = encrypt(lua_tostring(rl, 1), (int)lua_tostring(rl, 2));
			const auto& iv = encrypt(lua_tostring(rl, 1), (int)lua_tostring(rl, 2));

			lua_pushlstring(rl, encryptd.data(), encryptd.length());
			lua_pushlstring(rl, iv.data(), iv.length());
			return 2;
		}

		int crypt_decrypt(lua_State* rl)
		{
			const auto& decrypted = decrypt(lua_tostring(rl, 1), (int)lua_tostring(rl, 2));

			lua_pushlstring(rl, decrypted.data(), decrypted.length());
			return 1;
		}

		static std::string base64_encode(const std::string& in) {

			std::string out;

			int val = 0, valb = -6;
			for (unsigned char c : in) {
				val = (val << 8) + c;
				valb += 8;
				while (valb >= 0) {
					out.push_back("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(val >> valb) & 0x3F]);
					valb -= 6;
				}
			}
			if (valb > -6) out.push_back("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[((val << 8) >> (valb + 8)) & 0x3F]);
			while (out.size() % 4) out.push_back('=');
			return out;
		}

		static std::string base64_decode(const std::string& in) {

			std::string out;

			std::vector<int> T(256, -1);
			for (int i = 0; i < 64; i++) T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;

			int val = 0, valb = -8;
			for (unsigned char c : in) {
				if (T[c] == -1) break;
				val = (val << 6) + T[c];
				valb += 6;
				if (valb >= 0) {
					out.push_back(char((val >> valb) & 0xFF));
					valb -= 8;
				}
			}
			return out;
		}

		int crypt_base64encode(lua_State* rl)
		{
			const auto& encryptd = base64_encode(lua_tostring(rl, 1));

			lua_pushlstring(rl, encryptd.data(), encryptd.length());
			return 1;
		}

		int crypt_base64decode(lua_State* rl)
		{
			const auto& decrypted = base64_decode(lua_tostring(rl, 1));

			lua_pushlstring(rl, decrypted.data(), decrypted.length());
			return 1;
		}

		std::string gen_random(const int len) {
			static const char alphanum[] =
				"0123456789"
				"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
				"abcdefghijklmnopqrstuvwxyz";
			std::string tmp_s;
			tmp_s.reserve(len);

			for (int i = 0; i < len; ++i) {
				tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
			}

			return tmp_s;
		}

		std::string generate(int len)// n is size of the random string
		{
			std::string s(len, ' ');
			for (int i = 0; i < len; i++)
				s[i] = 'A' + (rand() % 26);

			return s;
		}

		int crypt_generatekey(lua_State* rl)
		{
			std::string key = gen_random(32);
			const auto& decrypted = base64_encode(key);

			lua_pushlstring(rl, decrypted.data(), decrypted.length());
			return 1;
		}


		int crypt_generatebytes(lua_State* rl)
		{
			std::string key = generate(lua_tointeger(rl, 1));
			const auto& decrypted = base64_encode(key);

			lua_pushlstring(rl, decrypted.data(), decrypted.length());
			return 1;
		}

		int crypt_hash(lua_State* RLS)
		{
			std::string option = lua_tostring(RLS, -2);
			std::string input = lua_tostring(RLS, -1);

			std::transform(option.begin(), option.end(), option.begin(), ::tolower);

			if (option == "sha512")
			{
				std::string output = sw::sha512::calculate(input);
				lua_pushstring(RLS, output.c_str());
				return 1;
			}

			if (option == "sha256")
			{
				std::string output = sha256(input);
				lua_pushstring(RLS, output.c_str());
				return 1;
			}

			if (option == "md5")
			{
				std::string output = Tools::GenerateHash(input.c_str(), input.length(), Tools::Hash::HashMd5);
				lua_pushstring(RLS, output.c_str());
				return 1;
			}

			std::string output = Tools::GenerateHash(input.c_str(), input.length(), Tools::Hash::HashMd5);
			lua_pushstring(RLS, output.c_str());
			return 1;
		}
	}

	namespace Input
	{
		int isrbxactive(lua_State* rl)
		{
			HWND window;
			window = FindWindowA(NULL, "Roblox");
			lua_pushboolean(rl, GetForegroundWindow() == window);
			return 1;
		}


		int mouse1press(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
			return 0;
		}


		int mouse1release(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
			return 0;
		}


		int mouse1click(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
			return 0;
		}


		int mouse2press(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);
			return 0;
		}


		int mouse2release(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
			return 0;
		}


		int mouse2click(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
			return 0;
		}


		int keypress(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			UINT key = luaL_checkinteger(rl, 1);

			if (GetForegroundWindow() == window)
				keybd_event(0, (BYTE)MapVirtualKeyA(key, MAPVK_VK_TO_VSC), KEYEVENTF_SCANCODE, 0);
			return 0;
		}


		int keyrelease(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			UINT key = luaL_checkinteger(rl, 1);

			if (GetForegroundWindow() == window)
				keybd_event(0, (BYTE)MapVirtualKeyA(key, MAPVK_VK_TO_VSC), KEYEVENTF_SCANCODE | KEYEVENTF_KEYUP, 0);
			return 0;
		}


		int mousemoverel(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");

			DWORD x = luaL_checkinteger(rl, 1);
			DWORD y = luaL_checkinteger(rl, 2);

			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_MOVE, x, y, 0, 0);
			return 0;
		}


		int mousemoveabs(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");

			DWORD x = luaL_checkinteger(rl, 1);
			DWORD y = luaL_checkinteger(rl, 2);

			if (GetForegroundWindow() != window) return 0;

			int width = GetSystemMetrics(SM_CXSCREEN) - 1;
			int height = GetSystemMetrics(SM_CYSCREEN) - 1;

			RECT CRect;
			GetClientRect(GetForegroundWindow(), &CRect);

			POINT Point{ CRect.left, CRect.top };
			ClientToScreen(GetForegroundWindow(), &Point);

			x = (x + (DWORD)Point.x) * (65535 / width);
			y = (y + (DWORD)Point.y) * (65535 / height);

			mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, x, y, 0, 0);

			return 0;
		}


		int mousescroll(lua_State* rl)
		{
			HWND window = FindWindowA(NULL, "Roblox");
			DWORD scroll_amount = luaL_checkinteger(rl, 1);

			if (GetForegroundWindow() == window)
				mouse_event(MOUSEEVENTF_WHEEL, 0, 0, scroll_amount, 0);
			return 0;
		}
	}

	namespace bit
	{
		int bit_band(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val & by;

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bdiv(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);//gets the numbers the user specified
			int by = lua_tointeger(RLS, -1, 0);//gets the numbers the user specified
			int ret = val / by;//does the action(devides)

			lua_pushinteger(RLS, ret);//returns what the thing got
			return 1;
		}

		int bit_badd(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val + by; //adds the values so if it was 10,5 it would be 15 because 10 + 5 = 15

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bsub(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val - by;//substracts

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bmul(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val * by;//multiplies

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bswap(lua_State* RLS)
		{

			int by = lua_tointeger(RLS, -1, 0);
			int ret = by >> 24 | by >> 8 & 0xff00 | (by & 0xff00) << 8 | by << 24;//swaps value
			lua_pushinteger(RLS, ret);
			return 1;
		}

		int leftRotate(unsigned n, unsigned d) {
			return (n << d) | (n >> (32 - d));
		}
		int rightRotate(unsigned n, unsigned d) {
			return (n >> d) | (n << (32 - d));
		}
		int bit_rol(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = leftRotate(val, by); //rotates left
			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_lshift(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val << by; //totates left

			lua_pushinteger(RLS, ret);

			return 1;
		}

		int bit_bor(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val | by;

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bxor(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val ^ by;

			lua_pushinteger(RLS, ret);
			return 1;
		}

		int bit_bnot(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -1, 0);
			int ret = ~val;

			lua_pushinteger(RLS, ret);

			return 1;
		}

		int bit_blshift(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val << by;

			lua_pushinteger(RLS, ret);

			return 1;
		}

		int bit_brshift(lua_State* RLS)
		{
			int val = lua_tointeger(RLS, -2, 0);
			int by = lua_tointeger(RLS, -1, 0);
			int ret = val >> by;

			lua_pushinteger(RLS, ret);

			return 1;
		}
	}

	namespace Debug
	{
		static int debug_getupvalue(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			int level;
			if (lua_isnumber(rl, 1))
			{
				level = lua_tointeger(rl, 1);
				luaL_argcheck(rl, level >= 0, 1, "level can't be negative");
			}
			else if (lua_isfunction(rl, 1))
			{
				level = lua_tointeger(rl, 1);
			}
			else
				luaL_argerror(rl, 1, "function or level expected");

			lua_Debug ar;
			if (lua_getinfo(rl, level, "f", &ar) == 0)
				luaL_argerror(rl, 1, "invalid level");

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				const auto idx = lua_tointeger(rl, 2);

				if (idx < 1 || idx > closure->nupvalues)
					luaL_error(rl, "upvalue index out of range");

				lua_getupvalue(rl, 1, idx);

				return 1;
			}

			return 0;
		}


		static int debug_getupvalues(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			int level;
			if (lua_isnumber(rl, 1))
			{
				level = lua_tointeger(rl, 1);
				luaL_argcheck(rl, level >= 0, 1, "level can't be negative");
			}
			else if (lua_isfunction(rl, 1))
			{
				level = lua_tointeger(rl, 1);
			}
			else
				luaL_argerror(rl, 1, "function or level expected");

			lua_Debug ar;
			if (lua_getinfo(rl, level, "f", &ar) == 0)
				luaL_argerror(rl, 1, "invalid level");

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				lua_createtable(rl, 0, 0);

				for (auto i = 0u; i < closure->nupvalues; ++i)
				{
					lua_getupvalue(rl, 1, i + 1);
					lua_rawseti(rl, -2, i + 1);
				}

				return 1;
			}

			return 0;
		}


		static int debug_setupvalue(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			int level;
			if (lua_isnumber(rl, 1))
			{
				level = lua_tointeger(rl, 1);
				luaL_argcheck(rl, level >= 0, 1, "level can't be negative");
			}
			else if (lua_isfunction(rl, 1))
			{
				level = lua_tointeger(rl, 1);
			}
			else
				luaL_argerror(rl, 1, "function or level expected");

			lua_Debug ar;
			if (lua_getinfo(rl, level, "f", &ar) == 0)
				luaL_argerror(rl, 1, "invalid level");

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				const auto idx = lua_tointeger(rl, 2);

				if (idx < 1 || idx > closure->nupvalues)
					luaL_error(rl, "upvalue index out of range");

				lua_pushvalue(rl, 3);
				lua_setupvalue(rl, 1, idx);
			}

			return 0;
		}


		static int debug_getconstant(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				const std::uint32_t idx = lua_tonumber(rl, 2) - 1;
				const auto constant = closure->l.p->k[idx];

				if (constant.tt == LUA_TTABLE || constant.tt == LUA_TFUNCTION)
					lua_pushnil(rl);
				else
				{
					rl->top->value = constant.value;
					rl->top->tt = constant.tt;

					rl->top++;
				}
			}
			else
				luaL_error(rl, "expected <lclosure> arg1");

			return 1;
		}


		static int debug_getconstants(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			const auto closure = clvalue(index2addr(rl, 1));

			if (!closure->isC)
			{
				lua_newtable(rl);

				for (auto i = 0; i < closure->l.p->sizek; ++i)
				{
					const auto constant = closure->l.p->k[i];

					if (constant.tt == LUA_TTABLE || constant.tt == LUA_TFUNCTION)
						lua_pushnil(rl);
					else
					{
						setobj(rl, rl->top, &constant);
						rl->top++;
					}

					lua_rawseti(rl, -2, i + 1);
				}
			}
			else
				luaL_error(rl, "expected <lclosure> arg1");

			return 1;
		}


		static int debug_setconstant(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				const std::uint32_t idx = lua_tonumber(rl, 2) - 1;
				const auto constant = &closure->l.p->k[idx];

				setobj(rl, constant, index2addr(rl, 3));
			}

			return 0;
		}


		static int debug_getinfo(lua_State* rl)
		{
			lua_Debug debug_info;
			std::size_t size;
			const auto optional_arg = luaL_optlstring(rl, 2, "flnas", &size);
			auto debug_options = std::string(optional_arg, size);

			std::int32_t level;
			if (lua_isnumber(rl, 1))
			{
				level = lua_tointeger(rl, 1);
				luaL_argcheck(rl, level >= 0, 1, "level can't be negative");
			}
			else if (lua_isfunction(rl, 1))
				level = lua_tointeger(rl, 1);
			else
				luaL_argerror(rl, 1, "function or level expected");

			if (!lua_getinfo(rl, level, debug_options.data(), &debug_info))
				luaL_error(rl, "getinfo failed");

			lua_newtable(rl);

			for (std::int8_t c : debug_options)
			{
				switch (c)
				{
				case 'a':
				{
					lua_pushnumber(rl, debug_info.isvararg);
					lua_setfield(rl, -2, ("is_vararg"));

					lua_pushinteger(rl, debug_info.nparams);
					lua_setfield(rl, -2, ("numparams"));

					lua_pushnumber(rl, debug_info.nupvals);
					lua_setfield(rl, -2, ("nups"));
					break;
				}
				case 'f':
				{
					lua_pushvalue(rl, -2);
					lua_setfield(rl, -2, ("func"));
					break;
				}
				case 'l':
				{
					lua_pushnumber(rl, debug_info.currentline);
					lua_setfield(rl, -2, ("currentline"));
					break;
				}
				case 'n':
				{
					lua_pushstring(rl, debug_info.name ? debug_info.name : "");
					lua_setfield(rl, -2, ("name"));
					break;
				}
				case 's':
				{
					lua_pushstring(rl, debug_info.source);
					lua_setfield(rl, -2, ("source"));

					lua_pushstring(rl, debug_info.short_src);
					lua_setfield(rl, -2, ("short_src"));

					lua_pushstring(rl, debug_info.what);
					lua_setfield(rl, -2, ("what"));
					break;
				}
				default:
					luaL_error(rl, "invalid debug option");
					break;
				}
			}

			return 1;
		}


		static int debug_getstack(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TNUMBER);

			const auto level = lua_tointeger(rl, 1);
			const auto index = luaL_optinteger(rl, 2, -1);

			lua_newtable(rl);

			if (level >= rl->ci - rl->base_ci || level < 0)
				luaL_argerror(rl, 1, "level out of range");

			const auto frame = reinterpret_cast<CallInfo*>(rl->ci - level);
			std::size_t top = (frame->top - frame->base);

			if (clvalue(frame->func)->isC)
				luaL_argerror(rl, 1, "level points to a cclosure, lclosure expected");

			if (index == -1)
			{
				for (int iter = 0; iter < top; iter++)
				{
					setobj2s(rl, rl->top, &frame->base[iter]);
					rl->top++;

					lua_rawseti(rl, -2, iter + 1);
				}
			}
			else
			{
				if (index < 1 || index > top)
					luaL_argerror(rl, 2, "index out of range");

				setobj2s(rl, rl->top, &frame->base[index - 1]);
				rl->top++;
			}

			return 1;
		}


		static int debug_setstack(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TNUMBER);
			luaL_checktype(rl, 2, LUA_TNUMBER);
			luaL_checkany(rl, 3);

			const auto level = lua_tointeger(rl, 1);
			const auto index = lua_tointeger(rl, 2);

			if (level >= rl->ci - rl->base_ci || level < 0)
				luaL_argerror(rl, 1, "level out of range");

			const auto frame = reinterpret_cast<CallInfo*>(rl->ci - level);
			std::size_t top = (frame->top - frame->base);

			if (clvalue(frame->func)->isC)
				luaL_argerror(rl, 1, "level points to a cclosure, lclosure expected");

			if (index < 1 || index > top)
				luaL_argerror(rl, 2, "index out of range");

			setobj2s(rl, &frame->base[index - 1], index2addr(rl, 3));

			return 0;
		}


		static int debug_getproto(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));
			bool reximode = luaL_optboolean(rl, 3, false);

			if (!closure->isC)
			{
				if (reximode)
					lua_newtable(rl);

				const std::uint32_t idx = lua_tonumber(rl, 2) - 1;
				const auto proto = closure->l.p->p[idx];

				setclvalue(rl, rl->top, luaF_newLclosure(rl, proto->nups, closure->env, proto));
				rl->top++;

				if (reximode)
					lua_rawseti(rl, -2, 1);
			}
			else
				luaL_error(rl, "expected <lclosure> arg1");

			return 1;
		}


		static int debug_getprotos(lua_State* rl)
		{
			luaL_checktype(rl, 1, LUA_TFUNCTION);

			const auto closure = *reinterpret_cast<Closure**>(index2addr(rl, 1));

			if (!closure->isC)
			{
				lua_createtable(rl, 0, 0);

				for (auto i = 0u; i < closure->l.p->sizep; ++i)
				{
					const auto proto = closure->l.p->p[i];

					setclvalue(rl, rl->top, luaF_newLclosure(rl, proto->nups, closure->env, proto));
					rl->top++;

					lua_rawseti(rl, -2, i + 1);
				}
			}
			else
				luaL_error(rl, "expected <lclosure> arg1");

			return 1;
		}
	}


	namespace Filesystem
	{

		int readfile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			const auto& read = ::filesystem::read(state, lua_tostring(state, 1));
			lua_pushlstring(state, read.c_str(), read.size());
			lua_pushstring(state, (const char*)"success");
			return 1;
		}

		int writefile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);
			luaL_checktype(state, 2, LUA_TSTRING);

			::filesystem::write(state, lua_tostring(state, 1), lua_tostring(state, 2));
			return 0;
		}

		int appendfile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);
			luaL_checktype(state, 2, LUA_TSTRING);

			::filesystem::append(state, lua_tostring(state, 1), lua_tostring(state, 2));
			return 0;
		}

		int listfiles(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			::filesystem::list(state, lua_tostring(state, 1));
			return 1;
		}

		int isfile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			lua_pushboolean(state, std::filesystem::is_regular_file(::filesystem::get_directory("workspace") / lua_tostring(state, 1)));
			return 1;
		}

		int isfolder(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			lua_pushboolean(state, std::filesystem::is_directory(::filesystem::get_directory("workspace") / lua_tostring(state, 1)));
			return 1;
		}

		int makefolder(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			std::filesystem::create_directories(::filesystem::get_directory("workspace") / lua_tostring(state, 1));
			return 0;
		}

		int delfile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			::filesystem::delfile(state, lua_tostring(state, 1));
			return 0;
		}

		int delfolder(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			::filesystem::delfolder(state, lua_tostring(state, 1));
			return 0;
		}

		int loadfile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			encoder enc;
			auto bytecode = Luau::compile(::filesystem::read(state, lua_tostring(state, 1)), {}, {}, &enc);

			if (luau_load(state, luaL_optstring(state, 2, "@"), bytecode.c_str(), bytecode.size(), 0))
			{
				lua_pushnil(state);
				lua_insert(state, -2);
				return 2;
			}
			lua_pushstring(state, (const char*)"2");
			return 1;
		}

		int dofile(lua_State* state)
		{
			luaL_checktype(state, 1, LUA_TSTRING);

			coderun_queue.push(::filesystem::read(state, lua_tostring(state, 1)));
			return 0;
		}
	}
}