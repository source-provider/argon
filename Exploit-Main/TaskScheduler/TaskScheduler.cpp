#include "TaskScheduler.hpp"


DWORD TaskScheduler::job_by_name(std::string name)
{
	DWORD job;
	DWORD start = *reinterpret_cast<DWORD*>(LuauCalls::scheduler() + 308);
	while (start != *reinterpret_cast<DWORD*>(LuauCalls::scheduler() + 312))
	{
		if (name == *reinterpret_cast<std::string*>(*reinterpret_cast<DWORD*>(start) + 16))
		{
			job = *reinterpret_cast<DWORD*>(start);
		}
		start += 8;
	}
	return job;
}


DWORD TaskScheduler::script_context()
{
	return *reinterpret_cast<DWORD*>(job_by_name("WaitingHybridScriptsJob") + 304);
}


DWORD TaskScheduler::lua_state()
{
	DWORD sc = script_context();
	return *reinterpret_cast<DWORD*>(sc + 244) - (sc + 244);
}


void TaskScheduler::set_fps(double fps)
{
	static const double min_frame_delay = 1.0 / 10000.0;
	double frame_delay = fps <= 0.0 ? min_frame_delay : 1.0 / fps;

	*reinterpret_cast<double*>(LuauCalls::scheduler() + 280) = frame_delay;
}


DWORD TaskScheduler::get_fps()
{
	return 1 / *reinterpret_cast<double*>(LuauCalls::scheduler() + 280);
}


#pragma pack(1)
struct patch_t
{
	BYTE nPatchType;
	DWORD dwAddress;
};
#pragma pack()


DWORD TaskScheduler::hook_job(DWORD job, void* hook)
{
	memcpy(new_vftable, *reinterpret_cast<void**>(job), 4u * 6u);

	auto old_vftable = *reinterpret_cast<DWORD**>(job);
	new_vftable[2] = reinterpret_cast<DWORD>(hook);

	*reinterpret_cast<DWORD**>(job) = new_vftable;
	return old_vftable[2];
}