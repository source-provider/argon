#pragma once

#include "lua.h"
#include "lcommon.h"

typedef union GCObject GCObject;

#define CommonHeader \
     shuffle3(uint8_t tt, uint8_t marked, uint8_t memcat);

typedef struct GCheader
{
    CommonHeader;
} GCheader;

typedef union
{
    GCObject* gc;
    void* p;
    double n;
    int b;
    float v[2];
} Value;

typedef struct lua_TValue
{
    Value value;
    int extra[LUA_EXTRA_SIZE];
    int tt;
} TValue;

#define ttisnil(o) (ttype(o) == LUA_TNIL)
#define ttisnumber(o) (ttype(o) == LUA_TNUMBER)
#define ttisstring(o) (ttype(o) == LUA_TSTRING)
#define ttistable(o) (ttype(o) == LUA_TTABLE)
#define ttisfunction(o) (ttype(o) == LUA_TFUNCTION)
#define ttisboolean(o) (ttype(o) == LUA_TBOOLEAN)
#define ttisuserdata(o) (ttype(o) == LUA_TUSERDATA)
#define ttisthread(o) (ttype(o) == LUA_TTHREAD)
#define ttislightuserdata(o) (ttype(o) == LUA_TLIGHTUSERDATA)
#define ttisvector(o) (ttype(o) == LUA_TVECTOR)
#define ttisupval(o) (ttype(o) == LUA_TUPVAL)

#define ttype(o) ((o)->tt)
#define gcvalue(o) check_exp(iscollectable(o), (o)->value.gc)
#define pvalue(o) check_exp(ttislightuserdata(o), (o)->value.p)
#define nvalue(o) check_exp(ttisnumber(o), (o)->value.n)
#define vvalue(o) check_exp(ttisvector(o), (o)->value.v)
#define tsvalue(o) check_exp(ttisstring(o), &(o)->value.gc->ts)
#define uvalue(o) check_exp(ttisuserdata(o), &(o)->value.gc->u)
#define clvalue(o) check_exp(ttisfunction(o), &(o)->value.gc->cl)
#define hvalue(o) check_exp(ttistable(o), &(o)->value.gc->h)
#define bvalue(o) check_exp(ttisboolean(o), (o)->value.b)
#define thvalue(o) check_exp(ttisthread(o), &(o)->value.gc->th)
#define upvalue(o) check_exp(ttisupval(o), &(o)->value.gc->uv)

#define l_isfalse(o) (ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))

#define checkconsistency(obj) LUAU_ASSERT(!iscollectable(obj) || (ttype(obj) == (obj)->value.gc->gch.tt))

#define checkliveness(g, obj) LUAU_ASSERT(!iscollectable(obj) || ((ttype(obj) == (obj)->value.gc->gch.tt) && !isdead(g, (obj)->value.gc)))

#define setnilvalue(obj) ((obj)->tt = LUA_TNIL)

#define setnvalue(obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.n = (x); \
        i_o->tt = LUA_TNUMBER; \
    }

#if LUA_VECTOR_SIZE == 4
#define setvvalue(obj, x, y, z, w) \
    { \
        TValue* i_o = (obj); \
        float* i_v = i_o->value.v; \
        i_v[0] = (x); \
        i_v[1] = (y); \
        i_v[2] = (z); \
        i_v[3] = (w); \
        i_o->tt = LUA_TVECTOR; \
    }
#else
#define setvvalue(obj, x, y, z, w) \
    { \
        TValue* i_o = (obj); \
        float* i_v = i_o->value.v; \
        i_v[0] = (x); \
        i_v[1] = (y); \
        i_v[2] = (z); \
        i_o->tt = LUA_TVECTOR; \
    }
#endif

#define setpvalue(obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.p = (x); \
        i_o->tt = LUA_TLIGHTUSERDATA; \
    }

#define setbvalue(obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.b = (x); \
        i_o->tt = LUA_TBOOLEAN; \
    }

#define setsvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TSTRING; \
        checkliveness(L->global, i_o); \
    }

#define setuvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TUSERDATA; \
        checkliveness(L->global, i_o); \
    }

#define setthvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TTHREAD; \
        checkliveness(L->global, i_o); \
    }

#define setclvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TFUNCTION; \
        checkliveness(L->global, i_o); \
    }

#define sethvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TTABLE; \
        checkliveness(L->global, i_o); \
    }

#define setptvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TPROTO; \
        checkliveness(L->global, i_o); \
    }

#define setupvalue(L, obj, x) \
    { \
        TValue* i_o = (obj); \
        i_o->value.gc = cast_to(GCObject*, (x)); \
        i_o->tt = LUA_TUPVAL; \
        checkliveness(L->global, i_o); \
    }

#define setobj(L, obj1, obj2) \
    { \
        const TValue* o2 = (obj2); \
        TValue* o1 = (obj1); \
        *o1 = *o2; \
        checkliveness(L->global, o1); \
    }

#define setobj2s setobj

#define setobjt2t setobj

#define setobj2t setobj

#define setobj2n setobj

#define setttype(obj, tt) (ttype(obj) = (tt))

#define iscollectable(o) (ttype(o) >= LUA_TSTRING)

typedef TValue* StkId;


typedef struct TString
{
    CommonHeader;

    int16_t atom;

    TString* next;

    vmvalue1<unsigned int> hash;
    vmvalue3<unsigned int> len;

    char data[1];
} TString;

#define getstr(ts) (ts)->data
#define svalue(o) getstr(tsvalue(o))


typedef struct Udata
{
    CommonHeader;

    uint8_t tag;

    int len;

    vmvalue3<struct Table*> metatable;

    union
    {
        char data[1];
        L_Umaxalign dummy;
    };
} Udata;


typedef struct Proto
{
    CommonHeader;

    shuffle8(
    vmvalue4<TValue*> k,
    vmvalue4<Instruction*> code,
    vmvalue4<struct Proto**> p,
    vmvalue4<uint8_t*> lineinfo,
    vmvalue4<int*> abslineinfo,
    vmvalue4<struct LocVar*> locvars,
    vmvalue4<TString**> upvalues,
    vmvalue4<TString*> source
    );

    vmvalue1<TString*> debugname; //36
    vmvalue3<uint8_t*> debuginsn; //40

    const Instruction* codeentry; //44
    void* execdata; //48
    uintptr_t exectarget; //52

    GCObject* gclist;

    shuffle9(
    int sizecode,
    int sizep,
    int sizelocvars,
    int sizeupvalues,
    int sizek,
    int sizelineinfo,
    int linegaplog2,
    int linedefined,
    int bytecodeid,
    );

    shuffle4(
    uint8_t nups,
    uint8_t numparams,
    uint8_t is_vararg,
    uint8_t maxstacksize
    );
} Proto;


typedef struct LocVar
{
    TString* varname;
    int startpc;
    int endpc;
    uint8_t reg;
} LocVar;


typedef struct UpVal
{
    CommonHeader;
    uint8_t markedopen;

    TValue* v;
    union
    {
        TValue value;
        struct
        {

            struct UpVal* prev;
            struct UpVal* next;

            struct UpVal* threadnext;
        } open;
    } u;
} UpVal;

#define upisopen(up) ((up)->v != &(up)->u.value)

typedef struct Closure
{
    CommonHeader;

    uint8_t isC;
    uint8_t nupvalues;
    uint8_t stacksize;
    uint8_t preload;

    GCObject* gclist;
    struct Table* env;

    union
    {
        struct
        {
            vmvalue3<lua_CFunction> f;
            vmvalue4<lua_Continuation> cont;
            vmvalue2<const char*> debugname;
            TValue upvals[1];
        } c;

        struct
        {
            vmvalue3<struct Proto*> p;
            TValue uprefs[1];
        } l;
    };
} Closure;

#define iscfunction(o) (ttype(o) == LUA_TFUNCTION && clvalue(o)->isC)
#define isLfunction(o) (ttype(o) == LUA_TFUNCTION && !clvalue(o)->isC)

typedef struct TKey
{
    ::Value value;
    int extra[LUA_EXTRA_SIZE];
    unsigned tt : 4;
    int next : 28;
} TKey;

typedef struct LuaNode
{
    TValue val;
    TKey key;
} LuaNode;

#define setnodekey(L, node, obj) \
    { \
        LuaNode* n_ = (node); \
        const TValue* i_o = (obj); \
        n_->key.value = i_o->value; \
        memcpy(n_->key.extra, i_o->extra, sizeof(n_->key.extra)); \
        n_->key.tt = i_o->tt; \
        checkliveness(L->global, i_o); \
    }

#define getnodekey(L, obj, node) \
    { \
        TValue* i_o = (obj); \
        const LuaNode* n_ = (node); \
        i_o->value = n_->key.value; \
        memcpy(i_o->extra, n_->key.extra, sizeof(i_o->extra)); \
        i_o->tt = n_->key.tt; \
        checkliveness(L->global, i_o); \
    }

typedef struct Table
{
    CommonHeader;

    shuffle5(
    uint8_t tmcache,
    uint8_t readonly,
    uint8_t safeenv,
    uint8_t lsizenode,
    uint8_t nodemask8
    );

    int sizearray;
    union
    {
        int lastfree;
        int aboundary;
    };

    shuffle4(
    vmvalue3<struct Table*> metatable,
    vmvalue3<TValue*> array,
    vmvalue3<LuaNode*> node,
    GCObject* gclist
    );
} Table;

#define lmod(s, size) (check_exp((size & (size - 1)) == 0, (cast_to(int, (s) & ((size)-1)))))

#define twoto(x) ((int)(1 << (x)))
#define sizenode(t) (twoto((t)->lsizenode))

#define luaO_nilobject (TValue*)_nilobject

#define ceillog2(x) (luaO_log2((x)-1) + 1)

LUAI_FUNC int luaO_log2(unsigned int x);
LUAI_FUNC int luaO_rawequalObj(const TValue* t1, const TValue* t2);
LUAI_FUNC int luaO_rawequalKey(const TKey* t1, const TValue* t2);
LUAI_FUNC int luaO_str2d(const char* s, double* result);
LUAI_FUNC const char* luaO_pushvfstring(lua_State* L, const char* fmt, va_list argp);
LUAI_FUNC const char* luaO_pushfstring(lua_State* L, const char* fmt, ...);
LUAI_FUNC const char* luaO_chunkid(char* buf, size_t buflen, const char* source, size_t srclen);


namespace LuauIdentity
{
    static void set(lua_State* rl, int identity)
    {
        *reinterpret_cast<int8_t*>(*reinterpret_cast<DWORD*>(reinterpret_cast<DWORD>(rl) + 72) + 24) = identity;
    }


    static int get(lua_State* rl)
    {
        return *reinterpret_cast<int8_t*>(*reinterpret_cast<DWORD*>(reinterpret_cast<DWORD>(rl) + 72) + 24);
    }
}


struct live_thread_ref
{
    int unk_0;
    lua_State* state;
    int state_id;
    int unk_1;
};


struct thread_ref
{
    live_thread_ref* ref;
    thread_ref(lua_State* L)
    {
        ref = new live_thread_ref;
        ref->unk_0 = 0;
        ref->state = L;
        lua_pushthread(L);
        ref->state_id = lua_ref(L, -1);
        lua_settop(L, 0);

        ref->unk_1 = 0;
    }
};


namespace LuauCalls
{
    using scheduler_t = DWORD(__cdecl*)();
    static scheduler_t scheduler = reinterpret_cast<scheduler_t>(_getscheduler);

    using taskdefer_t = DWORD(__cdecl*)(lua_State* rl);
    static taskdefer_t taskdefer = reinterpret_cast<taskdefer_t>(_taskdefer);

    using impersonator_t = void(__thiscall*)(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
    const impersonator_t impersonator = reinterpret_cast<impersonator_t>(_impersonator);

    using scresume_t = uintptr_t(__thiscall*)(int, thread_ref, int);
    const scresume_t scresume = reinterpret_cast<scresume_t>(_scriptcontextresume);

    using luavmload_t = uintptr_t(__fastcall*)(lua_State* rl, std::string* source, const char* chunk, int env);
    const luavmload_t luavmload = reinterpret_cast<luavmload_t>(_luavmload);

    using print_t = uintptr_t(__cdecl*)(int type, const char* source);
    const print_t print = reinterpret_cast<print_t>(_print);
}