#include <iostream>
#include <Windows.h>
#include <string>
#include <thread>
#include <vector>
#include <queue>
#include <map>
#include <fstream>
#include <sstream>

#include "Compiler/include/BytecodeBuilder.h"
#include "Compiler/include/Compiler.h"

#include "Luau/lobject.h"
#include "Luau/lstring.h"
#include "Luau/lua.h"
#include "Luau/lualib.h"
#include "Luau/lfunc.h"
#include "Luau/lmem.h"
#include "Luau/lgc.h"
#include "Luau/ltable.h"

#include "Tools.hpp"
#include "Compressor/include/xxhash.h"
#include "Compressor/include/zstd.h"



static std::queue<std::string> coderun_queue = {};


enum type
{
	roblox_c_closure,
	module_c_closure,
	module_c_wrap,
	l_closure,
	not_set
};


class encoder : public Luau::BytecodeEncoder
{
	std::uint8_t encodeOp(const std::uint8_t opcode)
	{
		return opcode * 227;
	}
};


static Table* getcurrenv(lua_State* L)
{
	if (L->ci == L->base_ci)
		return L->gt;
	else
		return curr_func(L)->env;
}


static LUAU_NOINLINE TValue* pseudo2addr(lua_State* L, int idx)
{
	api_check(L, lua_ispseudo(idx));
	switch (idx)
	{ // pseudo-indices
	case LUA_REGISTRYINDEX:
		return registry(L);
	case LUA_ENVIRONINDEX:
	{
		sethvalue(L, &L->global->pseudotemp, getcurrenv(L));
		return &L->global->pseudotemp;
	}
	case LUA_GLOBALSINDEX:
	{
		sethvalue(L, &L->global->pseudotemp, L->gt);
		return &L->global->pseudotemp;
	}
	default:
	{
		Closure* func = curr_func(L);
		idx = LUA_GLOBALSINDEX - idx;
		return (idx <= func->nupvalues) ? &func->c.upvals[idx - 1] : cast_to(TValue*, luaO_nilobject);
	}
	}
}


static LUAU_FORCEINLINE TValue* index2addr(lua_State* L, int idx)
{
	if (idx > 0)
	{
		TValue* o = L->base + (idx - 1);
		api_check(L, idx <= L->ci->top - L->base);
		if (o >= L->top)
			return cast_to(TValue*, luaO_nilobject);
		else
			return o;
	}
	else if (idx > LUA_REGISTRYINDEX)
	{
		api_check(L, idx != 0 && -idx <= L->top - L->base);
		return L->top + idx;
	}
	else
	{
		return pseudo2addr(L, idx);
	}
}


namespace Handler
{
	static std::map<Closure*, lua_CFunction> cfunction_map = {};
	static std::map<Closure*, Closure*> nccmap;

	static int cfunction_handler(lua_State* rl)
	{
		auto found = cfunction_map.find(curr_func(rl));

		if (found != cfunction_map.end())
		{
			return found->second(rl);
		}
		return 0;
	}

	static lua_CFunction retcheck_jmp = (lua_CFunction)cfunction_handler;


	static lua_CFunction get(Closure* cl)
	{
		return cfunction_map[cl];
	}


	static void set(Closure* cl, lua_CFunction cf)
	{
		cfunction_map[cl] = cf;
	}


	static void push(lua_State* rl, lua_CFunction fn, const char* debugname, int nup)
	{
		lua_pushcclosurek(rl, retcheck_jmp, debugname, nup, 0);
		Closure* closure = *reinterpret_cast<Closure**>(index2addr(rl, -1));
		cfunction_map[closure] = fn;
	}


	namespace wraps
	{
		static Closure* get(Closure* c)
		{
			return nccmap.find(c)->second;
		}

		static void set(Closure* c, Closure* l)
		{
			nccmap[c] = l;
		}
	}
}


namespace Offsets
{
	namespace Bytecode
	{
		const DWORD modulescript = 276;
		const DWORD localscript = 304;
	}
}


namespace Registration
{
	static void global(lua_State* rl, const char* name, lua_CFunction function)
	{
		Handler::push(rl, function, nullptr, 0);
		lua_setfield(rl, LUA_GLOBALSINDEX, name);
	}


	static void member(lua_State* rl, const char* name, lua_CFunction function)
	{
		Handler::push(rl, function, nullptr, 0);
		lua_setfield(rl, -2, name);
	}
}


namespace Compression
{
	static std::string compress(std::string source)
	{
		std::string output = "RSB1";
		std::size_t dataSize = source.size();
		std::size_t maxSize = ZSTD_compressBound(dataSize);
		std::vector<char> compressed(maxSize);
		std::size_t compSize = ZSTD_compress(&compressed[0], maxSize, source.c_str(), dataSize, ZSTD_maxCLevel());
		output.append(reinterpret_cast<char*>(&dataSize), sizeof(dataSize));
		output.append(&compressed[0], compSize);
		std::uint32_t firstHash = XXH32(&output[0], output.size(), 42U);
		std::uint8_t hashedBytes[4];
		std::memcpy(hashedBytes, &firstHash, sizeof(firstHash));
		for (std::size_t i = 0; i < output.size(); ++i)
			output[i] ^= hashedBytes[i % 4] + i * 41U;
		return output;
	}


	static std::string decompress(std::string source)
	{
		const char bytecode_magic[] = "RSB1";
		uint8_t hash_bytes[4];
		memcpy(hash_bytes, &source[0], 4);
		for (auto i = 0u; i < 4; ++i)
		{
			hash_bytes[i] ^= bytecode_magic[i];
			hash_bytes[i] -= i * 41;
		}
		for (size_t i = 0; i < source.size(); ++i)
			source[i] ^= hash_bytes[i % 4] + i * 41;
		XXH32(&source[0], source.size(), 42);
		uint32_t data_size;
		memcpy(&data_size, &source[4], 4);
		std::vector<uint8_t> zaazaa(data_size);
		ZSTD_decompress(&zaazaa[0], data_size, &source[8], source.size() - 8);
		return std::string((char*)(&zaazaa[0]), data_size);
	}
}


namespace filesystem
{
	static std::filesystem::path get_directory(const std::string& directory_name)
	{
        #pragma warning(suppress : 4996)
		std::filesystem::path local_appdata = std::filesystem::path(getenv("localappdata")) / "argon";

		if (!std::filesystem::exists(local_appdata))
			std::filesystem::create_directory(local_appdata);

		std::filesystem::path directory_path = local_appdata / directory_name;

		if (!std::filesystem::exists(directory_path))
			std::filesystem::create_directory(directory_path);

		return directory_path;
	}

	static std::string read(lua_State* state, const std::string& file_name)
	{
		std::filesystem::path file_path = get_directory("workspace") / file_name;

		if (!std::filesystem::is_regular_file(file_path))
		{
			luaL_error(state, "filesystem error.");
		}

		std::ifstream infile(file_path, std::ios::in | std::ios::binary | std::ios::ate);

		if (!infile.is_open())
		{
			luaL_error(state, "filesystem error.");
		}
		else
		{
			std::string file_content((std::istreambuf_iterator<char>(infile)), std::istreambuf_iterator<char>());
			infile.close();
			return file_content;
		}
	}

	static int list(lua_State* state, const std::string& folder_name)
	{
		std::filesystem::path folder_path = get_directory("workspace") / folder_name;

		if (!std::filesystem::exists(folder_path))
		{
			luaL_error(state, "not exists.");
		}

		int n{};
		lua_newtable(state);

		for (auto& entry : std::filesystem::directory_iterator(folder_path))
		{
			lua_pushstring(state, entry.path().string().c_str());
			lua_rawseti(state, -2, ++n);
		}
		return 1;
	}

	static void write(lua_State* state, const std::string& file_name, const std::string& file_content)
	{
		std::ofstream outfile(get_directory("workspace") / file_name, std::ios::out | std::ios::binary);

		if (!outfile.is_open())
		{
			luaL_error(state, "not opened.");
		}
		else
		{
			outfile.write(file_content.c_str(), file_content.size());
			outfile.close();
		}
	}

	static void append(lua_State* state, const std::string& file_name, const std::string& file_content)
	{
		std::filesystem::path file_path = get_directory("workspace") / file_name;

		if (!std::filesystem::is_regular_file(file_path))
		{
			luaL_error(state, "not file.");
		}

		std::ofstream appfile(file_path, std::ios::app | std::ios::binary);

		if (!appfile.is_open())
		{
			luaL_error(state, "not opened.");
		}
		else
		{
			appfile.write(file_content.c_str(), file_content.size());
			appfile.close();
		}
	}

	static void delfile(lua_State* state, const std::string& file_name)
	{
		std::filesystem::path file_path = get_directory("workspace") / file_name;

		if (!std::filesystem::is_regular_file(file_path))
		{
			luaL_error(state, "not file.");
		}

		std::filesystem::remove(file_path);
	}

	static void delfolder(lua_State* state, const std::string& folder_name)
	{
		std::filesystem::path folder_path = get_directory("workspace") / folder_name;

		if (!std::filesystem::exists(folder_path))
		{
			luaL_error(state, "not exists.");
		}

		std::filesystem::remove_all(folder_path);
	}
}